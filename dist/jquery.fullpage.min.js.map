{"version":3,"sources":["jquery.fullpage.js"],"names":["Util","onTransitionEnd","$element","cb","event","join","on","off","call","this","clamp","value","min","max","Math","Geometry","F","Object","defineProperty","get","_value","__get","set","newValue","__set","prototype","Error","Top","Base","create","constructor","position","top","newTop","css","Height","height","newHeight","GeometryManager","$","_top","_height","forEachProp","name","propName","replace","keys","forEach","proxy","reset","prop","jQuery","widget","rsharpe","slider","options","scrollStep","_create","_super","_on","wheel","e","isReady","ctrlKey","rawStep","originalEvent","deltaY","_scrollScreen","_init","_hasScreen","self","$item","screen","scroll","_trigger","element","scrolled","data","slide","sType","_refreshScreen","_onSlideEnd","_superApply","arguments","refresh","document","ready","$fp","fullpage","key","preventDefault","window","resize","state","matchMedia","matches","$inner","find","$area","draggable","axis","revert","drag","ui","HDelta","originalPosition","_repositionScrollbar","_onScroll","stop","aGm","$scrollbar","addClass","append","appendTo","scrollbar","trackDrag","_repositionAreaBy","normalTop","iGm","HRatio","_repositionArea","_updateAreaDraggable","_refreshScrollbar","y","sbTrackNormalTop","canScroll","sbTrackPercentageHeight","undefined","_doScroll","isDone","_onScrolled","step","dy","abs","$track","containment","tGm","_setOption","_setTrackHeight","_setTrackTop","percentageHeight","hide","show"],"mappings":"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","file":"jquery.fullpage.min.js","sourcesContent":["var Util = (function () {\r\n  'use strict';\r\n\r\n  var onTransitionEnd = function ($element, cb) {\r\n    var event = [\r\n      'transitionend',\r\n      'webkitTransitionEnd',\r\n      'oTransitionEnd',\r\n      'MSTransitionEnd'\r\n    ].join(' ');\r\n\r\n    $element.on(event, function () {\r\n      $element.off();\r\n      cb && cb.call(this);\r\n    });\r\n  };\r\n\r\n  // var equals = function ($a, $b) {\r\n  //   if (!$a || !$b || $a.length != $b.length) {\r\n  //     return false;\r\n  //   }\r\n\r\n  //   for (var i = 0; i < $a.length; i++) {\r\n  //     if ($a[i] !== $b[i]) {\r\n  //       return false;\r\n  //     }\r\n  //   }\r\n\r\n  //   return true;\r\n  // };\r\n\r\n  var clamp = function (value, min, max) {\r\n    return Math.min(\r\n      Math.max(value, min), \r\n      max\r\n    );\r\n  };\r\n\r\n  return {\r\n    onTransitionEnd: onTransitionEnd,\r\n    // equals: equals,\r\n    clamp: clamp,\r\n  };\r\n\r\n})();\nvar Geometry = (function () {\r\n  'use strict';\r\n\r\n  var F = function () {\r\n    Object.defineProperty(this, 'value', {\r\n      get: function () {\r\n        if (typeof this._value != 'number') {\r\n          this._value = this.__get();\r\n        }\r\n\r\n        return this._value;\r\n      },\r\n\r\n      set: function (newValue) {\r\n        this.__set(this._value = newValue);\r\n      },\r\n    });\r\n  };\r\n\r\n  F.prototype.__get = function () {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n  F.prototype.__set = function () {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n  return F;\r\n\r\n})();\r\n\r\nvar Top = (function (Base) {\r\n  'use strict';\r\n\r\n  var F = function ($element) {\r\n    this.$element = $element;\r\n    Base.call(this);\r\n  };\r\n\r\n  // Наследование должно всегда идти \r\n  // сразу после объявления конструктора\r\n  F.prototype = Object.create(Base.prototype);\r\n  F.prototype.constructor = F;\r\n\r\n  F.prototype.__get = function () {\r\n    var pos = this.$element.position();\r\n    return pos.top;\r\n  };\r\n\r\n  F.prototype.__set = function (newTop) {\r\n    // offset может устанавливать позицию некорректно\r\n    this.$element.css({ top: newTop });\r\n  };\r\n\r\n  return F;\r\n\r\n})(Geometry);\r\n\r\nvar Height = (function (Base) {\r\n  'use strict';\r\n\r\n  var F = function ($element) {\r\n    this.$element = $element;\r\n    Base.call(this);\r\n  };\r\n\r\n  F.prototype = Object.create(Base.prototype);\r\n  F.prototype.constructor = F;\r\n\r\n  F.prototype.__get = function () {\r\n    return this.$element.height();\r\n  };\r\n\r\n  F.prototype.__set = function (newHeight) {\r\n    this.$element.height(newHeight);\r\n  };\r\n\r\n  return F;\r\n\r\n})(Geometry);\r\n\r\nvar GeometryManager = (function ($) {\r\n  'use strict';\r\n\r\n  var F = function (top, height) {\r\n    this._top = top;\r\n    this._height = height;\r\n\r\n    forEachProp.call(this, function (name) {\r\n      var propName = name.replace('_', '');\r\n\r\n      Object.defineProperty(this, propName, {\r\n        get: function () {\r\n          return this[name].value;\r\n        },\r\n\r\n        set: function (newValue) {\r\n          this[name].value = newValue;\r\n        },\r\n      });\r\n    });\r\n  };\r\n\r\n  function forEachProp(cb) {\r\n    Object.keys(this).forEach($.proxy(cb, this));\r\n  }\r\n\r\n  F.prototype.reset = function (propName) {\r\n    if (!propName) {\r\n      forEachProp.call(this, function (name) {\r\n        this[name].value = null;\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    var prop = this['_' + propName];\r\n    prop && (prop.value = null);\r\n  };\r\n\r\n  F.create = function ($element) {\r\n    var top = new Top($element);\r\n    var height = new Height($element);\r\n    return new F(top, height);\r\n  };\r\n\r\n  return F;\r\n\r\n})(jQuery);\n;\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.fullpage', $.rsharpe.slider, {\r\n    options: {\r\n      scrollStep: 100,\r\n    },\r\n\r\n    _create: function () {\r\n      this._super();\r\n\r\n      // Tоже что и this._on(this.element, {});\r\n      this._on({\r\n        wheel: function (e) {\r\n          if (!this.isReady || e.ctrlKey) {\r\n            return;\r\n          }\r\n\r\n          var rawStep = e.originalEvent.deltaY;\r\n          rawStep = Util.clamp(rawStep, -1, 1);\r\n          rawStep *= this.options.scrollStep;\r\n\r\n          this._scrollScreen(rawStep);\r\n        },\r\n      });\r\n    },\r\n\r\n    // Этот метод также вызывается из коробки, \r\n    // сразу после вызова _create\r\n    _init: function () {\r\n      if (!this._hasScreen()) {\r\n        var self = this;\r\n\r\n        this.$item.screen({\r\n          scroll: function (e) {\r\n            self._trigger('scroll', e, { element: this });\r\n          },\r\n          scrolled: function (e, data) {\r\n            self.slide(data.sType);\r\n            // self._trigger('scrolled', e, { element: this });\r\n          }\r\n        });\r\n      }\r\n\r\n      // HACK: Дополнительно вызываем событие чтобы поймать scrollpoint enter и exit\r\n      this._trigger('scroll', null, { element: this.$item[0] });\r\n \r\n      // Дополнительно обновляем экран, \r\n      // т.к. при перелистывании могут быть \r\n      // расхождения в позиционировании area\r\n      this._refreshScreen();\r\n    },\r\n\r\n    _onSlideEnd: function () {\r\n      this._superApply(arguments);\r\n      this._init();\r\n    },\r\n\r\n    refresh: function () {\r\n      this._refreshScreen();\r\n    },\r\n\r\n    _refreshScreen: function () {\r\n      if (!this._hasScreen()) {\r\n        return;\r\n      }\r\n\r\n      this.$item.screen('refresh');\r\n    },\r\n\r\n    _scrollScreen: function (rawStep) {\r\n      if (!this._hasScreen()) {\r\n        return;\r\n      }\r\n\r\n      this.$item.screen('scroll', rawStep);\r\n    },\r\n\r\n    _hasScreen: function () {\r\n      return !!this.$item.screen('instance');\r\n    },\r\n  });\r\n\r\n  $(document).ready(function () {\r\n    // var $fp = $('.fp-container:first')\r\n    //   .fullpage().on('fullpagescroll', function (e, data) { \r\n    //     console.log(data); \r\n    //   });\r\n\r\n    var $fp = $('.fp-container:first')\r\n      .fullpage();\r\n\r\n    $(this).on('keyup keydown', function (e) {\r\n      switch (e.key) {\r\n        case 'ArrowUp':\r\n          $fp.fullpage('slide', 'prev');\r\n          e.preventDefault();\r\n          break;\r\n\r\n        case 'ArrowDown':\r\n          $fp.fullpage('slide', 'next');\r\n          e.preventDefault();\r\n          break;\r\n      }\r\n    });\r\n\r\n    $(window).resize(function () {\r\n      // На моб. экранах плагин не нужен, \r\n      // поэтому отключаем его, чтобы не выполнялось \r\n      // лишний раз событие wheel из fullpage\r\n\r\n      var mQuery = '(min-width: 768px)';\r\n      var state = this.matchMedia(mQuery).matches ?\r\n        'enable' :\r\n        'disable';\r\n\r\n      $fp.fullpage(state);\r\n      state == 'enable' && $fp.fullpage('refresh');\r\n    });\r\n  });\r\n\r\n})(jQuery);\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.screen', {\r\n    _create: function () {\r\n      var self = this;\r\n\r\n      this.$inner = this.element\r\n        .find('.fp-screen-inner:first');\r\n\r\n      this.$area = this.$inner\r\n        .find('.fp-screen-area:first')\r\n        .draggable({\r\n          axis: 'y',\r\n          scroll: false,\r\n          revert: true,\r\n          drag: function (e, ui) {\r\n            if (self.isReady) {\r\n              // Значение ui более корректно, по сравнению с aGm.top\r\n              // Если вместо ui брать aGm тогда будут происходить \r\n              // маленькие сдвиги назад. Значение aGm статично, \r\n              // тогда как ui может плавать, после того \r\n              // как событие drag уже произошло\r\n              var top = Util.clamp(ui.position.top, self.HDelta, 0);\r\n              ui.originalPosition.top = top;\r\n\r\n              self._repositionScrollbar(top);\r\n              self._onScroll();\r\n            }\r\n          },\r\n          stop: function () {\r\n            // Событие вызывается после того как \r\n            // revert draggable элемент (area) вернется обратно.\r\n\r\n            // ~~~~~\r\n            // Если не обновить здесь еще раз top, тогда в нем \r\n            // будет храниться значение из последнего drag \r\n            // (т.е. выше или ниже допустимых границ), а нужно то,\r\n            // что будет после того как area, вернется обратно\r\n            // ~~~~~\r\n\r\n            if (self.isReady) {\r\n              self.aGm.reset('top');\r\n            }\r\n          },\r\n        });\r\n\r\n      this.$scrollbar = createScrollbar()\r\n        .appendTo(this.$inner)\r\n        .scrollbar({\r\n          trackDrag: function (e, data) {\r\n            if (self.isReady) {\r\n              self._repositionAreaBy(data.normalTop);\r\n              self._onScroll();\r\n            }\r\n          },\r\n        });\r\n\r\n      this.iGm = GeometryManager.create(this.$inner);\r\n      this.aGm = GeometryManager.create(this.$area);\r\n\r\n      this.isReady = true;\r\n    },\r\n\r\n    refresh: function () {\r\n      this.iGm.reset();\r\n      this.aGm.reset();\r\n\r\n      this.HDelta = this.iGm.height - this.aGm.height;\r\n      this.HRatio = this.iGm.height / this.aGm.height;\r\n\r\n      this._repositionArea();\r\n      this._updateAreaDraggable();\r\n\r\n      this._refreshScrollbar();\r\n    },\r\n\r\n    _repositionArea: function () {\r\n      var y = this.aGm.top - this.HDelta;\r\n\r\n      if (y < 0) {\r\n        this.aGm.top = Math.min(0, this.aGm.top - y);\r\n      }\r\n    },\r\n\r\n    _repositionAreaBy: function (sbTrackNormalTop) {\r\n      this.aGm.top = this.aGm.height * sbTrackNormalTop * -1;\r\n    },\r\n\r\n    _updateAreaDraggable: function () {\r\n      var state = this.canScroll() ? 'enable' : 'disable';\r\n      this.$area.draggable(state);\r\n    },\r\n\r\n    _refreshScrollbar: function () {\r\n      var sbTrackPercentageHeight = this.HRatio * 100;\r\n\r\n      this.$scrollbar\r\n        .scrollbar('refresh')\r\n        .scrollbar(\r\n          'option',\r\n          'trackHeight',\r\n          sbTrackPercentageHeight\r\n        );\r\n\r\n      this._repositionScrollbar();\r\n    },\r\n\r\n    _repositionScrollbar: function (top) {\r\n      top === undefined && (top = this.aGm.top);\r\n\r\n      var sbTrackNormalTop = top < 0 ?\r\n        top / this.aGm.height * -1 :\r\n        0;\r\n\r\n      this.$scrollbar.scrollbar(\r\n        'option',\r\n        'trackTop',\r\n        sbTrackNormalTop\r\n      );\r\n    },\r\n\r\n    scroll: function (rawStep) {\r\n      if (!rawStep) {\r\n        return;\r\n      }\r\n\r\n      if (!this.canScroll()) {\r\n        this._onScrolled(rawStep);\r\n        return;\r\n      }\r\n\r\n      this._doScroll(rawStep, function (isDone) {\r\n        if (isDone) {\r\n          this._onScrolled(rawStep);\r\n          return;\r\n        }\r\n\r\n        this._repositionScrollbar();\r\n        this._onScroll();\r\n      });\r\n    },\r\n\r\n    canScroll: function () {\r\n      return this.HRatio < 1;\r\n    },\r\n\r\n    _doScroll: function (step, cb) {\r\n      if (!step) {\r\n        return;\r\n      }\r\n\r\n      var y = this.aGm.top - step;\r\n      var dy = Math.abs(step);\r\n\r\n      if ((y - 1) < (this.HDelta - dy) || (y + 1) > dy) {\r\n        cb && cb.call(this, true);\r\n        return;\r\n      }\r\n\r\n      this.aGm.top = Util.clamp(y, this.HDelta, 0);\r\n      cb && cb.call(this);\r\n\r\n      // Вариант ленивой прокрутки, когда area может прокрутиться\r\n      // не до конца, и перейти к следующему экрану\r\n      // if (y < this.HDelta || y > 0) {\r\n      //   cb && cb.call(this, true);\r\n      //   return;\r\n      // }\r\n\r\n      // Вариант когда area прокручивается до конца, \r\n      // и только после этого переходит к следующему экрану\r\n      // if ((y - 1) < (this.HDelta - Math.abs(step) || (y + 1) > Math.abs(step)) {\r\n      //   cb && cb.call(this, true);\r\n      //   return;\r\n      // }\r\n    },\r\n\r\n    _onScroll: function () {\r\n      this._trigger('scroll');\r\n    },\r\n\r\n    _onScrolled: function (rawStep) {\r\n      if (!rawStep) {\r\n        return;\r\n      }\r\n\r\n      var sType = rawStep > 0 ? 'next' : 'prev';\r\n      this._trigger('scrolled', null, { sType: sType });\r\n    },\r\n  });\r\n\r\n  function createScrollbar() {\r\n    return $('<div>')\r\n      .addClass('fp-scrollbar')\r\n      .append(\r\n        $('<div>')\r\n          .addClass('fp-scrollbar-inner')\r\n          .append(\r\n            $('<div>').addClass('fp-scrollbar-track')\r\n          )\r\n      );\r\n  }\r\n\r\n})(jQuery);\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.scrollbar', {\r\n    _create: function () {\r\n      var self = this;\r\n\r\n      this.$inner = this.element\r\n        .find('.fp-scrollbar-inner:first');\r\n\r\n      this.$track = this.$inner\r\n        .find('.fp-scrollbar-track:first')\r\n        .draggable({\r\n          axis: 'y',\r\n          scroll: false,\r\n          containment: 'parent',\r\n          drag: function (e) {\r\n            if (self.isReady) {\r\n              self.tGm.reset('top');\r\n\r\n              var top = self.tGm.top > 0 ?\r\n                self.tGm.top / self.iGm.height :\r\n                0;\r\n\r\n              // Если передавать сразу top вместо объекта, \r\n              // тогда при значении 0 он будет преобразован \r\n              // в пустой объект, что вызовет ошибку\r\n              self._trigger('trackDrag', e, { normalTop: top });\r\n            }\r\n          },\r\n        });\r\n\r\n      this.iGm = GeometryManager.create(this.$inner);\r\n      this.tGm = GeometryManager.create(this.$track);\r\n\r\n      this.isReady = true;\r\n    },\r\n\r\n    refresh: function () {\r\n      this.iGm.reset();\r\n      this.tGm.reset();\r\n    },\r\n\r\n    _setOption: function (key, value) {\r\n      switch (key) {\r\n        case 'trackHeight':\r\n          this._setTrackHeight(value);\r\n          break;\r\n\r\n        case 'trackTop':\r\n          this._setTrackTop(value);\r\n          break;\r\n      }\r\n\r\n      this._super(key, value);\r\n    },\r\n\r\n    _setTrackHeight: function (percentageHeight) {\r\n      if (percentageHeight > 99) {\r\n        this.element.hide();\r\n        return;\r\n      }\r\n\r\n      this.tGm.height = percentageHeight + '%';\r\n      this.element.show();\r\n    },\r\n\r\n    _setTrackTop: function (normalTop) {\r\n      this.tGm.top = this.iGm.height * normalTop;\r\n    },\r\n  });\r\n\r\n})(jQuery);\r\n\r\n\r\n// -------------------------\r\n\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.fullpage', $.rsharpe.slider, {\r\n//     options: {\r\n//       scrollStep: 100,\r\n//     },\r\n\r\n//     _create: function () {\r\n//       this._super();\r\n\r\n//       this._on(this.element, {\r\n//         wheel: function (e) {\r\n//           if (!this.isReady || e.ctrlKey) {\r\n//             return;\r\n//           }\r\n\r\n//           var rawStep = e.originalEvent.deltaY;\r\n//           rawStep = Utils.clamp(rawStep, -1, 1);\r\n//           rawStep *= this.options.scrollStep;\r\n\r\n//           this._scrollScreen(rawStep);\r\n//         },\r\n//       });\r\n//     },\r\n\r\n//     _onSlideEnd: function () {\r\n//       this._superApply(arguments);\r\n//       this._init();\r\n//     },\r\n\r\n//     // Этот метод также вызывается из коробки, \r\n//     // сразу после вызова _create\r\n//     _init: function () {\r\n//       if (this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       var self = this;\r\n\r\n//       this.$item.screen({\r\n//         scrolled: function (e, data) {\r\n//           self.slide(data.sType);\r\n//         }\r\n//       });\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this._refreshScreen(); // -> $('.fp-screen').screen('refresh');\r\n//     },\r\n\r\n//     _refreshScreen: function () {\r\n//       if (!this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       this.$item.screen('refresh');\r\n//     },\r\n\r\n//     _scrollScreen: function (rawStep) {\r\n//       if (!this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       this.$item.screen('scroll', rawStep);\r\n//     },\r\n\r\n//     _hasScreen: function () {\r\n//       return !!this.$item.screen('instance');\r\n//     },\r\n//   });\r\n\r\n// })(jQuery);\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.screen', {\r\n//     _create: function () {\r\n//       var self = this;\r\n\r\n//       this.$inner = this.element\r\n//         .find('.fp-screen-inner:first');\r\n\r\n//       this.$area = this.$inner\r\n//         .find('.fp-screen-area:first')\r\n//         .draggable({\r\n//           axis: 'y',\r\n//           scroll: false,\r\n//           revert: true,\r\n//           drag: function (e, ui) {\r\n//             if (self.isReady) {\r\n//               // Значение ui более корректно, по сравнению с aGm.top\r\n//               // Если вместо ui брать aGm тогда будут происходить \r\n//               // маленькие сдвиги назад. Значение aGm статично, \r\n//               // тогда как ui может плавать, после того \r\n//               // как событие drag уже произошло\r\n//               var top = Utils.clamp(ui.position.top, self.HDelta, 0);\r\n//               ui.originalPosition.top = top;\r\n//               self._repositionScrollbar(top);\r\n//             }\r\n//           },\r\n//           stop: function () {\r\n//             // Событие вызывается после того как \r\n//             // revert draggable элемент (area) вернется обратно.\r\n\r\n//             // ~~~~~\r\n//             // Если не обновить здесь еще раз top, тогда в нем \r\n//             // будет храниться значение из последнего drag \r\n//             // (т.е. выше или ниже допустимых границ), а нужно то,\r\n//             // что будет после того как area, вернется обратно\r\n//             // ~~~~~\r\n\r\n//             if (self.isReady) {\r\n//               self.aGm.reset('top');\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.$scrollbar = createScrollbar()\r\n//         .appendTo(this.$inner)\r\n//         .scrollbar({\r\n//           trackDrag: function (e, data) {\r\n//             if (self.isReady) {\r\n//               self._repositionAreaBy(data.normalTop);\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.iGm = GeometryManager.create(this.$inner);\r\n//       this.aGm = GeometryManager.create(this.$area);\r\n\r\n//       this.refresh();\r\n//       this.isReady = true;\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this.iGm.reset();\r\n//       this.aGm.reset();\r\n\r\n//       this.HDelta = this.iGm.height - this.aGm.height;\r\n//       this.HRatio = this.iGm.height / this.aGm.height;\r\n\r\n//       this._repositionArea();\r\n//       this._updateAreaDrag();\r\n\r\n//       this._refreshScrollbar();\r\n//     },\r\n\r\n//     _repositionArea: function () {\r\n//       var y = this.aGm.top - this.HDelta;\r\n\r\n//       if (y < 0) {\r\n//         this.aGm.top = Math.min(0, this.aGm.top - y);\r\n//       }\r\n//     },\r\n\r\n//     _repositionAreaBy: function (sbTrackNormalTop) {\r\n//       this.aGm.top = this.aGm.height * sbTrackNormalTop * -1;\r\n//     },\r\n\r\n//     _updateAreaDrag: function () {\r\n//       var state = this.canScroll() ? 'enable' : 'disable';\r\n//       this.$area.draggable(state);\r\n//     },\r\n\r\n//     _refreshScrollbar: function () {\r\n//       var sbTrackPercentageHeight = this.HRatio * 100;\r\n\r\n//       this.$scrollbar\r\n//         .scrollbar('refresh')\r\n//         .scrollbar(\r\n//           'option',\r\n//           'trackHeight',\r\n//           sbTrackPercentageHeight\r\n//         );\r\n\r\n//       this._repositionScrollbar();\r\n//     },\r\n\r\n//     _repositionScrollbar: function (top) {\r\n//       top === undefined && (top = this.aGm.top);\r\n\r\n//       var sbTrackNormalTop = top < 0 ?\r\n//         top / this.aGm.height * -1 :\r\n//         0;\r\n\r\n//       this.$scrollbar.scrollbar(\r\n//         'option',\r\n//         'trackTop',\r\n//         sbTrackNormalTop\r\n//       );\r\n//     },\r\n\r\n//     scroll: function (rawStep) {\r\n//       if (!rawStep) {\r\n//         return;\r\n//       }\r\n\r\n//       if (!this.canScroll()) {\r\n//         this._onScrolled(rawStep);\r\n//         return;\r\n//       }\r\n\r\n//       this._doScroll(rawStep, function (isDone) {\r\n//         if (isDone) {\r\n//           this._onScrolled(rawStep);\r\n//           return;\r\n//         }\r\n\r\n//         this._repositionScrollbar();\r\n//       });\r\n//     },\r\n\r\n//     canScroll: function () {\r\n//       return this.HRatio < 1;\r\n//     },\r\n\r\n//     _doScroll: function (step, cb) {\r\n//       if (!step) {\r\n//         return;\r\n//       }\r\n\r\n//       var y = this.aGm.top - step;\r\n//       var dy = Math.abs(step);\r\n\r\n//       if ((y - 1) < (this.HDelta - dy) || (y + 1) > dy) {\r\n//         cb && cb.call(this, true);\r\n//         return;\r\n//       }\r\n\r\n//       this.aGm.top = Utils.clamp(y, this.HDelta, 0);\r\n//       cb && cb.call(this);\r\n\r\n//       // Вариант ленивой прокрутки, когда area может прокрутиться\r\n//       // не до конца, и перейти к следующему экрану\r\n//       // if (y < this.HDelta || y > 0) {\r\n//       //   cb && cb.call(this, true);\r\n//       //   return;\r\n//       // }\r\n\r\n//       // Вариант когда area прокручивается до конца, \r\n//       // и только после этого переходит к следующему экрану\r\n//       // if ((y - 1) < (this.HDelta - Math.abs(step) || (y + 1) > Math.abs(step)) {\r\n//       //   cb && cb.call(this, true);\r\n//       //   return;\r\n//       // }\r\n//     },\r\n\r\n//     _onScrolled: function (rawStep) {\r\n//       if (!rawStep) {\r\n//         return;\r\n//       }\r\n\r\n//       var sType = rawStep > 0 ? 'next' : 'prev';\r\n//       this._trigger('scrolled', null, { sType: sType });\r\n//     },\r\n//   });\r\n\r\n//   function createScrollbar() {\r\n//     return $('<div>')\r\n//       .addClass('fp-scrollbar')\r\n//       .append(\r\n//         $('<div>')\r\n//           .addClass('fp-scrollbar-inner')\r\n//           .append(\r\n//             $('<div>').addClass('fp-scrollbar-track')\r\n//           )\r\n//       );\r\n//   }\r\n\r\n// })(jQuery);\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.scrollbar', {\r\n//     _create: function () {\r\n//       var self = this;\r\n\r\n//       this.$inner = this.element\r\n//         .find('.fp-scrollbar-inner:first');\r\n\r\n//       this.$track = this.$inner\r\n//         .find('.fp-scrollbar-track:first')\r\n//         .draggable({\r\n//           axis: 'y',\r\n//           scroll: false,\r\n//           containment: 'parent',\r\n//           drag: function (e) {\r\n//             if (self.isReady) {\r\n//               self.tGm.reset('top');\r\n\r\n//               var top = self.tGm.top > 0 ?\r\n//                 self.tGm.top / self.iGm.height :\r\n//                 0;\r\n\r\n//               // Если передавать сразу top вместо объекта, \r\n//               // тогда при значении 0 он будет преобразован \r\n//               // в пустой объект, что вызовет ошибку\r\n//               self._trigger('trackDrag', e, { normalTop: top });\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.iGm = GeometryManager.create(this.$inner);\r\n//       this.tGm = GeometryManager.create(this.$track);\r\n\r\n//       this.isReady = true;\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this.iGm.reset();\r\n//       this.tGm.reset();\r\n//     },\r\n\r\n//     _setOption: function (key, value) {\r\n//       switch (key) {\r\n//         case 'trackHeight':\r\n//           this._setTrackHeight(value);\r\n//           break;\r\n\r\n//         case 'trackTop':\r\n//           this._setTrackTop(value);\r\n//           break;\r\n//       }\r\n\r\n//       this._super(key, value);\r\n//     },\r\n\r\n//     _setTrackHeight: function (percentageHeight) {\r\n//       if (percentageHeight > 99) {\r\n//         this.element.hide();\r\n//         return;\r\n//       }\r\n\r\n//       this.tGm.height = percentageHeight + '%';\r\n//       this.element.show();\r\n//     },\r\n\r\n//     _setTrackTop: function (normalTop) {\r\n//       this.tGm.top = this.iGm.height * normalTop;\r\n//     },\r\n//   });\r\n\r\n// })(jQuery);\r\n//# sourceMappingURL=jquery.fullpage.js.map\r\n"]}