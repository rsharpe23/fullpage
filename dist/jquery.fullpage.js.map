{"version":3,"sources":["util.js","geometry-api.js","jquery.fullpage.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery.fullpage.js","sourcesContent":["var Util = (function () {\r\n  'use strict';\r\n\r\n  var onTransitionEnd = function ($element, cb) {\r\n    var event = [\r\n      'transitionend',\r\n      'webkitTransitionEnd',\r\n      'oTransitionEnd',\r\n      'MSTransitionEnd'\r\n    ].join(' ');\r\n\r\n    $element.on(event, function () {\r\n      $element.off();\r\n      cb && cb.call(this);\r\n    });\r\n  };\r\n\r\n  // var equals = function ($a, $b) {\r\n  //   if (!$a || !$b || $a.length != $b.length) {\r\n  //     return false;\r\n  //   }\r\n\r\n  //   for (var i = 0; i < $a.length; i++) {\r\n  //     if ($a[i] !== $b[i]) {\r\n  //       return false;\r\n  //     }\r\n  //   }\r\n\r\n  //   return true;\r\n  // };\r\n\r\n  var clamp = function (value, min, max) {\r\n    return Math.min(\r\n      Math.max(value, min), \r\n      max\r\n    );\r\n  };\r\n\r\n  return {\r\n    onTransitionEnd: onTransitionEnd,\r\n    // equals: equals,\r\n    clamp: clamp,\r\n  };\r\n\r\n})();","var Geometry = (function () {\r\n  'use strict';\r\n\r\n  var F = function () {\r\n    Object.defineProperty(this, 'value', {\r\n      get: function () {\r\n        if (typeof this._value != 'number') {\r\n          this._value = this.__get();\r\n        }\r\n\r\n        return this._value;\r\n      },\r\n\r\n      set: function (newValue) {\r\n        this.__set(this._value = newValue);\r\n      },\r\n    });\r\n  };\r\n\r\n  F.prototype.__get = function () {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n  F.prototype.__set = function () {\r\n    throw new Error('Not implemented');\r\n  };\r\n\r\n  return F;\r\n\r\n})();\r\n\r\nvar Top = (function (Base) {\r\n  'use strict';\r\n\r\n  var F = function ($element) {\r\n    this.$element = $element;\r\n    Base.call(this);\r\n  };\r\n\r\n  // Наследование должно всегда идти \r\n  // сразу после объявления конструктора\r\n  F.prototype = Object.create(Base.prototype);\r\n  F.prototype.constructor = F;\r\n\r\n  F.prototype.__get = function () {\r\n    var pos = this.$element.position();\r\n    return pos.top;\r\n  };\r\n\r\n  F.prototype.__set = function (newTop) {\r\n    // offset может устанавливать позицию некорректно\r\n    this.$element.css({ top: newTop });\r\n  };\r\n\r\n  return F;\r\n\r\n})(Geometry);\r\n\r\nvar Height = (function (Base) {\r\n  'use strict';\r\n\r\n  var F = function ($element) {\r\n    this.$element = $element;\r\n    Base.call(this);\r\n  };\r\n\r\n  F.prototype = Object.create(Base.prototype);\r\n  F.prototype.constructor = F;\r\n\r\n  F.prototype.__get = function () {\r\n    return this.$element.height();\r\n  };\r\n\r\n  F.prototype.__set = function (newHeight) {\r\n    this.$element.height(newHeight);\r\n  };\r\n\r\n  return F;\r\n\r\n})(Geometry);\r\n\r\nvar GeometryManager = (function ($) {\r\n  'use strict';\r\n\r\n  var F = function (top, height) {\r\n    this._top = top;\r\n    this._height = height;\r\n\r\n    forEachProp.call(this, function (name) {\r\n      var propName = name.replace('_', '');\r\n\r\n      Object.defineProperty(this, propName, {\r\n        get: function () {\r\n          return this[name].value;\r\n        },\r\n\r\n        set: function (newValue) {\r\n          this[name].value = newValue;\r\n        },\r\n      });\r\n    });\r\n  };\r\n\r\n  function forEachProp(cb) {\r\n    Object.keys(this).forEach($.proxy(cb, this));\r\n  }\r\n\r\n  F.prototype.reset = function (propName) {\r\n    if (!propName) {\r\n      forEachProp.call(this, function (name) {\r\n        this[name].value = null;\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    var prop = this['_' + propName];\r\n    prop && (prop.value = null);\r\n  };\r\n\r\n  F.create = function ($element) {\r\n    var top = new Top($element);\r\n    var height = new Height($element);\r\n    return new F(top, height);\r\n  };\r\n\r\n  return F;\r\n\r\n})(jQuery);",";\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.fullpage', $.rsharpe.slider, {\r\n    options: {\r\n      scrollStep: 100,\r\n    },\r\n\r\n    _create: function () {\r\n      this._super();\r\n\r\n      // Tоже что и this._on(this.element, {});\r\n      this._on({\r\n        wheel: function (e) {\r\n          if (!this.isReady || e.ctrlKey) {\r\n            return;\r\n          }\r\n\r\n          var rawStep = e.originalEvent.deltaY;\r\n          rawStep = Util.clamp(rawStep, -1, 1);\r\n          rawStep *= this.options.scrollStep;\r\n\r\n          this._scrollScreen(rawStep);\r\n        },\r\n      });\r\n    },\r\n\r\n    // Этот метод также вызывается из коробки, \r\n    // сразу после вызова _create\r\n    _init: function () {\r\n      if (!this._hasScreen()) {\r\n        var self = this;\r\n\r\n        this.$item.screen({\r\n          scroll: function (e) {\r\n            self._trigger('scroll', e, { element: this });\r\n          },\r\n          scrolled: function (e, data) {\r\n            self.slide(data.sType);\r\n            // self._trigger('scrolled', e, { element: this });\r\n          }\r\n        });\r\n      }\r\n\r\n      // HACK: Дополнительно вызываем событие чтобы поймать scrollpoint enter и exit\r\n      this._trigger('scroll', null, { element: this.$item[0] });\r\n \r\n      // Дополнительно обновляем экран, \r\n      // т.к. при перелистывании могут быть \r\n      // расхождения в позиционировании area\r\n      this._refreshScreen();\r\n    },\r\n\r\n    _onSlideEnd: function () {\r\n      this._superApply(arguments);\r\n      this._init();\r\n    },\r\n\r\n    refresh: function () {\r\n      this._refreshScreen();\r\n    },\r\n\r\n    _refreshScreen: function () {\r\n      if (!this._hasScreen()) {\r\n        return;\r\n      }\r\n\r\n      this.$item.screen('refresh');\r\n    },\r\n\r\n    _scrollScreen: function (rawStep) {\r\n      if (!this._hasScreen()) {\r\n        return;\r\n      }\r\n\r\n      this.$item.screen('scroll', rawStep);\r\n    },\r\n\r\n    _hasScreen: function () {\r\n      return !!this.$item.screen('instance');\r\n    },\r\n  });\r\n\r\n  $(document).ready(function () {\r\n    // var $fp = $('.fp-container:first')\r\n    //   .fullpage().on('fullpagescroll', function (e, data) { \r\n    //     console.log(data); \r\n    //   });\r\n\r\n    var $fp = $('.fp-container:first')\r\n      .fullpage();\r\n\r\n    $(this).on('keyup keydown', function (e) {\r\n      switch (e.key) {\r\n        case 'ArrowUp':\r\n          $fp.fullpage('slide', 'prev');\r\n          e.preventDefault();\r\n          break;\r\n\r\n        case 'ArrowDown':\r\n          $fp.fullpage('slide', 'next');\r\n          e.preventDefault();\r\n          break;\r\n      }\r\n    });\r\n\r\n    $(window).resize(function () {\r\n      // На моб. экранах плагин не нужен, \r\n      // поэтому отключаем его, чтобы не выполнялось \r\n      // лишний раз событие wheel из fullpage\r\n\r\n      var mQuery = '(min-width: 768px)';\r\n      var state = this.matchMedia(mQuery).matches ?\r\n        'enable' :\r\n        'disable';\r\n\r\n      $fp.fullpage(state);\r\n      state == 'enable' && $fp.fullpage('refresh');\r\n    });\r\n  });\r\n\r\n})(jQuery);\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.screen', {\r\n    _create: function () {\r\n      var self = this;\r\n\r\n      this.$inner = this.element\r\n        .find('.fp-screen-inner:first');\r\n\r\n      this.$area = this.$inner\r\n        .find('.fp-screen-area:first')\r\n        .draggable({\r\n          axis: 'y',\r\n          scroll: false,\r\n          revert: true,\r\n          drag: function (e, ui) {\r\n            if (self.isReady) {\r\n              // Значение ui более корректно, по сравнению с aGm.top\r\n              // Если вместо ui брать aGm тогда будут происходить \r\n              // маленькие сдвиги назад. Значение aGm статично, \r\n              // тогда как ui может плавать, после того \r\n              // как событие drag уже произошло\r\n              var top = Util.clamp(ui.position.top, self.HDelta, 0);\r\n              ui.originalPosition.top = top;\r\n\r\n              self._repositionScrollbar(top);\r\n              self._onScroll();\r\n            }\r\n          },\r\n          stop: function () {\r\n            // Событие вызывается после того как \r\n            // revert draggable элемент (area) вернется обратно.\r\n\r\n            // ~~~~~\r\n            // Если не обновить здесь еще раз top, тогда в нем \r\n            // будет храниться значение из последнего drag \r\n            // (т.е. выше или ниже допустимых границ), а нужно то,\r\n            // что будет после того как area, вернется обратно\r\n            // ~~~~~\r\n\r\n            if (self.isReady) {\r\n              self.aGm.reset('top');\r\n            }\r\n          },\r\n        });\r\n\r\n      this.$scrollbar = createScrollbar()\r\n        .appendTo(this.$inner)\r\n        .scrollbar({\r\n          trackDrag: function (e, data) {\r\n            if (self.isReady) {\r\n              self._repositionAreaBy(data.normalTop);\r\n              self._onScroll();\r\n            }\r\n          },\r\n        });\r\n\r\n      this.iGm = GeometryManager.create(this.$inner);\r\n      this.aGm = GeometryManager.create(this.$area);\r\n\r\n      this.isReady = true;\r\n    },\r\n\r\n    refresh: function () {\r\n      this.iGm.reset();\r\n      this.aGm.reset();\r\n\r\n      this.HDelta = this.iGm.height - this.aGm.height;\r\n      this.HRatio = this.iGm.height / this.aGm.height;\r\n\r\n      this._repositionArea();\r\n      this._updateAreaDraggable();\r\n\r\n      this._refreshScrollbar();\r\n    },\r\n\r\n    _repositionArea: function () {\r\n      var y = this.aGm.top - this.HDelta;\r\n\r\n      if (y < 0) {\r\n        this.aGm.top = Math.min(0, this.aGm.top - y);\r\n      }\r\n    },\r\n\r\n    _repositionAreaBy: function (sbTrackNormalTop) {\r\n      this.aGm.top = this.aGm.height * sbTrackNormalTop * -1;\r\n    },\r\n\r\n    _updateAreaDraggable: function () {\r\n      var state = this.canScroll() ? 'enable' : 'disable';\r\n      this.$area.draggable(state);\r\n    },\r\n\r\n    _refreshScrollbar: function () {\r\n      var sbTrackPercentageHeight = this.HRatio * 100;\r\n\r\n      this.$scrollbar\r\n        .scrollbar('refresh')\r\n        .scrollbar(\r\n          'option',\r\n          'trackHeight',\r\n          sbTrackPercentageHeight\r\n        );\r\n\r\n      this._repositionScrollbar();\r\n    },\r\n\r\n    _repositionScrollbar: function (top) {\r\n      top === undefined && (top = this.aGm.top);\r\n\r\n      var sbTrackNormalTop = top < 0 ?\r\n        top / this.aGm.height * -1 :\r\n        0;\r\n\r\n      this.$scrollbar.scrollbar(\r\n        'option',\r\n        'trackTop',\r\n        sbTrackNormalTop\r\n      );\r\n    },\r\n\r\n    scroll: function (rawStep) {\r\n      if (!rawStep) {\r\n        return;\r\n      }\r\n\r\n      if (!this.canScroll()) {\r\n        this._onScrolled(rawStep);\r\n        return;\r\n      }\r\n\r\n      this._doScroll(rawStep, function (isDone) {\r\n        if (isDone) {\r\n          this._onScrolled(rawStep);\r\n          return;\r\n        }\r\n\r\n        this._repositionScrollbar();\r\n        this._onScroll();\r\n      });\r\n    },\r\n\r\n    canScroll: function () {\r\n      return this.HRatio < 1;\r\n    },\r\n\r\n    _doScroll: function (step, cb) {\r\n      if (!step) {\r\n        return;\r\n      }\r\n\r\n      var y = this.aGm.top - step;\r\n      var dy = Math.abs(step);\r\n\r\n      if ((y - 1) < (this.HDelta - dy) || (y + 1) > dy) {\r\n        cb && cb.call(this, true);\r\n        return;\r\n      }\r\n\r\n      this.aGm.top = Util.clamp(y, this.HDelta, 0);\r\n      cb && cb.call(this);\r\n\r\n      // Вариант ленивой прокрутки, когда area может прокрутиться\r\n      // не до конца, и перейти к следующему экрану\r\n      // if (y < this.HDelta || y > 0) {\r\n      //   cb && cb.call(this, true);\r\n      //   return;\r\n      // }\r\n\r\n      // Вариант когда area прокручивается до конца, \r\n      // и только после этого переходит к следующему экрану\r\n      // if ((y - 1) < (this.HDelta - Math.abs(step) || (y + 1) > Math.abs(step)) {\r\n      //   cb && cb.call(this, true);\r\n      //   return;\r\n      // }\r\n    },\r\n\r\n    _onScroll: function () {\r\n      this._trigger('scroll');\r\n    },\r\n\r\n    _onScrolled: function (rawStep) {\r\n      if (!rawStep) {\r\n        return;\r\n      }\r\n\r\n      var sType = rawStep > 0 ? 'next' : 'prev';\r\n      this._trigger('scrolled', null, { sType: sType });\r\n    },\r\n  });\r\n\r\n  function createScrollbar() {\r\n    return $('<div>')\r\n      .addClass('fp-scrollbar')\r\n      .append(\r\n        $('<div>')\r\n          .addClass('fp-scrollbar-inner')\r\n          .append(\r\n            $('<div>').addClass('fp-scrollbar-track')\r\n          )\r\n      );\r\n  }\r\n\r\n})(jQuery);\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  $.widget('rsharpe.scrollbar', {\r\n    _create: function () {\r\n      var self = this;\r\n\r\n      this.$inner = this.element\r\n        .find('.fp-scrollbar-inner:first');\r\n\r\n      this.$track = this.$inner\r\n        .find('.fp-scrollbar-track:first')\r\n        .draggable({\r\n          axis: 'y',\r\n          scroll: false,\r\n          containment: 'parent',\r\n          drag: function (e) {\r\n            if (self.isReady) {\r\n              self.tGm.reset('top');\r\n\r\n              var top = self.tGm.top > 0 ?\r\n                self.tGm.top / self.iGm.height :\r\n                0;\r\n\r\n              // Если передавать сразу top вместо объекта, \r\n              // тогда при значении 0 он будет преобразован \r\n              // в пустой объект, что вызовет ошибку\r\n              self._trigger('trackDrag', e, { normalTop: top });\r\n            }\r\n          },\r\n        });\r\n\r\n      this.iGm = GeometryManager.create(this.$inner);\r\n      this.tGm = GeometryManager.create(this.$track);\r\n\r\n      this.isReady = true;\r\n    },\r\n\r\n    refresh: function () {\r\n      this.iGm.reset();\r\n      this.tGm.reset();\r\n    },\r\n\r\n    _setOption: function (key, value) {\r\n      switch (key) {\r\n        case 'trackHeight':\r\n          this._setTrackHeight(value);\r\n          break;\r\n\r\n        case 'trackTop':\r\n          this._setTrackTop(value);\r\n          break;\r\n      }\r\n\r\n      this._super(key, value);\r\n    },\r\n\r\n    _setTrackHeight: function (percentageHeight) {\r\n      if (percentageHeight > 99) {\r\n        this.element.hide();\r\n        return;\r\n      }\r\n\r\n      this.tGm.height = percentageHeight + '%';\r\n      this.element.show();\r\n    },\r\n\r\n    _setTrackTop: function (normalTop) {\r\n      this.tGm.top = this.iGm.height * normalTop;\r\n    },\r\n  });\r\n\r\n})(jQuery);\r\n\r\n\r\n// -------------------------\r\n\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.fullpage', $.rsharpe.slider, {\r\n//     options: {\r\n//       scrollStep: 100,\r\n//     },\r\n\r\n//     _create: function () {\r\n//       this._super();\r\n\r\n//       this._on(this.element, {\r\n//         wheel: function (e) {\r\n//           if (!this.isReady || e.ctrlKey) {\r\n//             return;\r\n//           }\r\n\r\n//           var rawStep = e.originalEvent.deltaY;\r\n//           rawStep = Utils.clamp(rawStep, -1, 1);\r\n//           rawStep *= this.options.scrollStep;\r\n\r\n//           this._scrollScreen(rawStep);\r\n//         },\r\n//       });\r\n//     },\r\n\r\n//     _onSlideEnd: function () {\r\n//       this._superApply(arguments);\r\n//       this._init();\r\n//     },\r\n\r\n//     // Этот метод также вызывается из коробки, \r\n//     // сразу после вызова _create\r\n//     _init: function () {\r\n//       if (this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       var self = this;\r\n\r\n//       this.$item.screen({\r\n//         scrolled: function (e, data) {\r\n//           self.slide(data.sType);\r\n//         }\r\n//       });\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this._refreshScreen(); // -> $('.fp-screen').screen('refresh');\r\n//     },\r\n\r\n//     _refreshScreen: function () {\r\n//       if (!this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       this.$item.screen('refresh');\r\n//     },\r\n\r\n//     _scrollScreen: function (rawStep) {\r\n//       if (!this._hasScreen()) {\r\n//         return;\r\n//       }\r\n\r\n//       this.$item.screen('scroll', rawStep);\r\n//     },\r\n\r\n//     _hasScreen: function () {\r\n//       return !!this.$item.screen('instance');\r\n//     },\r\n//   });\r\n\r\n// })(jQuery);\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.screen', {\r\n//     _create: function () {\r\n//       var self = this;\r\n\r\n//       this.$inner = this.element\r\n//         .find('.fp-screen-inner:first');\r\n\r\n//       this.$area = this.$inner\r\n//         .find('.fp-screen-area:first')\r\n//         .draggable({\r\n//           axis: 'y',\r\n//           scroll: false,\r\n//           revert: true,\r\n//           drag: function (e, ui) {\r\n//             if (self.isReady) {\r\n//               // Значение ui более корректно, по сравнению с aGm.top\r\n//               // Если вместо ui брать aGm тогда будут происходить \r\n//               // маленькие сдвиги назад. Значение aGm статично, \r\n//               // тогда как ui может плавать, после того \r\n//               // как событие drag уже произошло\r\n//               var top = Utils.clamp(ui.position.top, self.HDelta, 0);\r\n//               ui.originalPosition.top = top;\r\n//               self._repositionScrollbar(top);\r\n//             }\r\n//           },\r\n//           stop: function () {\r\n//             // Событие вызывается после того как \r\n//             // revert draggable элемент (area) вернется обратно.\r\n\r\n//             // ~~~~~\r\n//             // Если не обновить здесь еще раз top, тогда в нем \r\n//             // будет храниться значение из последнего drag \r\n//             // (т.е. выше или ниже допустимых границ), а нужно то,\r\n//             // что будет после того как area, вернется обратно\r\n//             // ~~~~~\r\n\r\n//             if (self.isReady) {\r\n//               self.aGm.reset('top');\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.$scrollbar = createScrollbar()\r\n//         .appendTo(this.$inner)\r\n//         .scrollbar({\r\n//           trackDrag: function (e, data) {\r\n//             if (self.isReady) {\r\n//               self._repositionAreaBy(data.normalTop);\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.iGm = GeometryManager.create(this.$inner);\r\n//       this.aGm = GeometryManager.create(this.$area);\r\n\r\n//       this.refresh();\r\n//       this.isReady = true;\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this.iGm.reset();\r\n//       this.aGm.reset();\r\n\r\n//       this.HDelta = this.iGm.height - this.aGm.height;\r\n//       this.HRatio = this.iGm.height / this.aGm.height;\r\n\r\n//       this._repositionArea();\r\n//       this._updateAreaDrag();\r\n\r\n//       this._refreshScrollbar();\r\n//     },\r\n\r\n//     _repositionArea: function () {\r\n//       var y = this.aGm.top - this.HDelta;\r\n\r\n//       if (y < 0) {\r\n//         this.aGm.top = Math.min(0, this.aGm.top - y);\r\n//       }\r\n//     },\r\n\r\n//     _repositionAreaBy: function (sbTrackNormalTop) {\r\n//       this.aGm.top = this.aGm.height * sbTrackNormalTop * -1;\r\n//     },\r\n\r\n//     _updateAreaDrag: function () {\r\n//       var state = this.canScroll() ? 'enable' : 'disable';\r\n//       this.$area.draggable(state);\r\n//     },\r\n\r\n//     _refreshScrollbar: function () {\r\n//       var sbTrackPercentageHeight = this.HRatio * 100;\r\n\r\n//       this.$scrollbar\r\n//         .scrollbar('refresh')\r\n//         .scrollbar(\r\n//           'option',\r\n//           'trackHeight',\r\n//           sbTrackPercentageHeight\r\n//         );\r\n\r\n//       this._repositionScrollbar();\r\n//     },\r\n\r\n//     _repositionScrollbar: function (top) {\r\n//       top === undefined && (top = this.aGm.top);\r\n\r\n//       var sbTrackNormalTop = top < 0 ?\r\n//         top / this.aGm.height * -1 :\r\n//         0;\r\n\r\n//       this.$scrollbar.scrollbar(\r\n//         'option',\r\n//         'trackTop',\r\n//         sbTrackNormalTop\r\n//       );\r\n//     },\r\n\r\n//     scroll: function (rawStep) {\r\n//       if (!rawStep) {\r\n//         return;\r\n//       }\r\n\r\n//       if (!this.canScroll()) {\r\n//         this._onScrolled(rawStep);\r\n//         return;\r\n//       }\r\n\r\n//       this._doScroll(rawStep, function (isDone) {\r\n//         if (isDone) {\r\n//           this._onScrolled(rawStep);\r\n//           return;\r\n//         }\r\n\r\n//         this._repositionScrollbar();\r\n//       });\r\n//     },\r\n\r\n//     canScroll: function () {\r\n//       return this.HRatio < 1;\r\n//     },\r\n\r\n//     _doScroll: function (step, cb) {\r\n//       if (!step) {\r\n//         return;\r\n//       }\r\n\r\n//       var y = this.aGm.top - step;\r\n//       var dy = Math.abs(step);\r\n\r\n//       if ((y - 1) < (this.HDelta - dy) || (y + 1) > dy) {\r\n//         cb && cb.call(this, true);\r\n//         return;\r\n//       }\r\n\r\n//       this.aGm.top = Utils.clamp(y, this.HDelta, 0);\r\n//       cb && cb.call(this);\r\n\r\n//       // Вариант ленивой прокрутки, когда area может прокрутиться\r\n//       // не до конца, и перейти к следующему экрану\r\n//       // if (y < this.HDelta || y > 0) {\r\n//       //   cb && cb.call(this, true);\r\n//       //   return;\r\n//       // }\r\n\r\n//       // Вариант когда area прокручивается до конца, \r\n//       // и только после этого переходит к следующему экрану\r\n//       // if ((y - 1) < (this.HDelta - Math.abs(step) || (y + 1) > Math.abs(step)) {\r\n//       //   cb && cb.call(this, true);\r\n//       //   return;\r\n//       // }\r\n//     },\r\n\r\n//     _onScrolled: function (rawStep) {\r\n//       if (!rawStep) {\r\n//         return;\r\n//       }\r\n\r\n//       var sType = rawStep > 0 ? 'next' : 'prev';\r\n//       this._trigger('scrolled', null, { sType: sType });\r\n//     },\r\n//   });\r\n\r\n//   function createScrollbar() {\r\n//     return $('<div>')\r\n//       .addClass('fp-scrollbar')\r\n//       .append(\r\n//         $('<div>')\r\n//           .addClass('fp-scrollbar-inner')\r\n//           .append(\r\n//             $('<div>').addClass('fp-scrollbar-track')\r\n//           )\r\n//       );\r\n//   }\r\n\r\n// })(jQuery);\r\n\r\n// (function ($) {\r\n//   'use strict';\r\n\r\n//   $.widget('rsharpe.scrollbar', {\r\n//     _create: function () {\r\n//       var self = this;\r\n\r\n//       this.$inner = this.element\r\n//         .find('.fp-scrollbar-inner:first');\r\n\r\n//       this.$track = this.$inner\r\n//         .find('.fp-scrollbar-track:first')\r\n//         .draggable({\r\n//           axis: 'y',\r\n//           scroll: false,\r\n//           containment: 'parent',\r\n//           drag: function (e) {\r\n//             if (self.isReady) {\r\n//               self.tGm.reset('top');\r\n\r\n//               var top = self.tGm.top > 0 ?\r\n//                 self.tGm.top / self.iGm.height :\r\n//                 0;\r\n\r\n//               // Если передавать сразу top вместо объекта, \r\n//               // тогда при значении 0 он будет преобразован \r\n//               // в пустой объект, что вызовет ошибку\r\n//               self._trigger('trackDrag', e, { normalTop: top });\r\n//             }\r\n//           },\r\n//         });\r\n\r\n//       this.iGm = GeometryManager.create(this.$inner);\r\n//       this.tGm = GeometryManager.create(this.$track);\r\n\r\n//       this.isReady = true;\r\n//     },\r\n\r\n//     refresh: function () {\r\n//       this.iGm.reset();\r\n//       this.tGm.reset();\r\n//     },\r\n\r\n//     _setOption: function (key, value) {\r\n//       switch (key) {\r\n//         case 'trackHeight':\r\n//           this._setTrackHeight(value);\r\n//           break;\r\n\r\n//         case 'trackTop':\r\n//           this._setTrackTop(value);\r\n//           break;\r\n//       }\r\n\r\n//       this._super(key, value);\r\n//     },\r\n\r\n//     _setTrackHeight: function (percentageHeight) {\r\n//       if (percentageHeight > 99) {\r\n//         this.element.hide();\r\n//         return;\r\n//       }\r\n\r\n//       this.tGm.height = percentageHeight + '%';\r\n//       this.element.show();\r\n//     },\r\n\r\n//     _setTrackTop: function (normalTop) {\r\n//       this.tGm.top = this.iGm.height * normalTop;\r\n//     },\r\n//   });\r\n\r\n// })(jQuery);"]}